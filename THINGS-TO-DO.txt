
WHERE AM I
* 05-PEG-Grammar.bmx
* Add metadata tags to parsenodes - DONE
* Add parse errors as tags....
- Currently the loaded CSV is failing to parse using the production parser
    - Theer is no error recovery or reporting in the manual or production  parser so
    - we have no way to know what is wrong.
- We need to test it with the manual parser first
- Then  we need to add metatag parsing and metatdata to the manual parser
    - METADATA( key, value, pattern ). The metatadta is added to the node produced by the 
    - pattern.
- Then we need to add some labels and errorrs into manual parser
- then we need to populate the metatdata within the TErrorOperator

- Combine CHARSET and RANGE
    - Include leading "^" to reverse the meaning of the character set

- Change getGrammarABNF() to getGrammar( "ABNF" ) and add registerGrammar( "ABNF", factory:TGrammar() )
  - Packrat.abnf can then add a factory function and register itself.
  - Packrat.regex can do the same
  - Packrat.peg can do the same (for its core rules)

PEG SELFTEST
In packrat.peg/peg.bmx, CreateParserFromPEG(), enable "Print pegparser.grammar.toPeg()"
* Do the same with the production parser and check output is the same.

BUGS
Symbols will use the following escape sequences from RFC5234 (ABNF definition)
    "\x" <value>

   Hence:
         CR          =  %d13
         CR          =  %x0D

* Pakrat.Regex uses rule names starting with "\", these are not currently
  supported by the parser so cannot be used.

FEATURES
- Add helper BETWEEN( x, y ) allowing a string to be converted to a number and have a range check
 - Returns True if Between and false otherwise
- Optimise some of the Operators, we dont need to do character comparisions for them
- RANGE and CHARSET are similar, chnage them to ONEOF (or something)
  - Fix the negative range issue [^0-9] meaning not in 0 to 9


--------------------------------------------------------------------------------------

*. Fix LINE and BLOCK comments

* Replace escape() and deescape() in parser.bmx
    - Move them into TPattern as encode() and decode() so they can be over-ridden if necessary
    - Standardise on escape symbols instead of /xNNN or /UNNN
        - What does ABNF use for unicode? %XXXX or &NNN; etc...

* Current way of catching an error
    LINE -> _* ( EOL / RULE / COMMENT / BADLINE ) 
    BADLINE -> ( !EOL . )* EOL

    - Implement labels
    - Return label == null, we backtrack with nothing found
    - Return label == nonterminal (rule) we execute that rule to clean up
    - Return label == missing non-terminal, Produce "Unexpected symbols at"

    LINE <- SP EOL / RULE / SOMETHING^recovery
    recovery <- (!EOL . )* EOL 

    Improve LABELs

    A label is currently processed by the patternm but it should not.
    A Lbal is nothign more than a non terminal that is used like choice

    myrule^label is the same as ( myrule | label )

    So in TPattern.fail(), you should simply: Return New TNonTerminal( label )
    if label is set and result.node = null

* Add support For directives in PEG file:
! KEY = VALUE

    Current directives:
    !START=Blitzmax
    !RESERVEDWORDS=	' Used to prevent keywords from being reserved words

* Strings:

    String = '"' value:(!(eol / '"') .)+ '"' { return value; }
           / '"' value:(!(eol / '"') .)+     { error('unterminated string constant'); return value; }

* "EXPECTED" ERROR MESSAGES

        number -> [0-9]*
        sum => number "+" number

    grammar.parse( "3 + A" )    "Expected 'number' at 5"

        number "integer" -> [0-9]*
        sum => number "+" number

    grammar.parse( "3 + A" )    "Expected 'integer' at 5"

POST IMPLEMENTATION CLEANUP





